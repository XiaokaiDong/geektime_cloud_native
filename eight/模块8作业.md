# 模块8作业

## 作业要求

作业一要求：

> 编写 Kubernetes 部署脚本将 httpserver 部署到 kubernetes 集群，以下是你可以思考的维度
>
> - 优雅启动
> - 优雅终止
> - 资源需求和 QoS 保证
> - 探活
> - 日常运维需求，日志等级
> - 配置和代码分离

作业二要求：

> 除了将 httpServer 应用优雅的运行在 Kubernetes 之上，我们还应该考虑如何将服务发布给对内和对外的调用方。
> 来尝试用 Service, Ingress 将你的服务发布给集群外部的调用方吧
> 在第一部分的基础上提供更加完备的部署 spec，包括（不限于）
>
> - Service
> - Ingress
>
> 可以考虑的细节
>
> - 如何确保整个应用的高可用
> - 如何通过证书保证 httpServer 的通讯安全

本次作业没有严格按照要求来写，没有使用httpserver，而是结合工作中的一个实际服务card-bill（基于java springboot）进行编写，因为目前部门仍然以单体架构为主，本次作业是尝试探讨将现有应用部署在K8S集群中的一个尝试。

### 服务现状及其改造点

card-bill服务的情况如下：

- 原始启动方式是通过shell脚本启动jar包，因为shell不响应SIG-TERM信号，所以改成直接在POD中通过java -jar的命令启动程序；
- card-bill使用application.properties作为配置文件。配置文件以configmap的形式挂载到相应目录，细节参见“配置和代码分离”小节。
- 密钥配置相关。原服务配置在application.properties中，需要改成secret，详见“编写Secret”小节。

- card-bill的日志输出到日志文件而不是stdout，这里就不改输出的凡是了，将日志使用emptyDir来保存。

- 使用java实现的分布式缓存hazelcast，hazelcast也运行与JAVA主进程中。

  

## 作业答案

### 作业一

> 编写 Kubernetes 部署脚本将 httpserver 部署到 kubernetes 集群，以下是你可以思考的维度
>
> - 优雅启动
> - 优雅终止
> - 资源需求和 QoS 保证
> - 探活
> - 日常运维需求，日志等级
> - 配置和代码分离

#### 编写Dockerfile

```dockerfile
FROM java:8
LABEL seg=card
COPY ./cardbill-1.0.jar /app/
EXPOSE 9090
WORKDIR /app
ENTRYPOINT nohup java
CMD -server -Xmx1G -Xms1G \
  -XX:+UseG1GC -XX:MaxGCPauseMillis=20 \
  -Djava.security.egd=file:/dev/./urandom \
  -XX:InitiatingHeapOccupancyPercent=35 -XX:+DisableExplicitGC -Djava.awt.headless=true \
  -jar cardbill-1.0.jar  \
  > /dev/null 2>&1 &
```

#### 构建镜像

```shell
sudo docker build -t cardbill:1.0 .
```

#### 编写configmap

该java应用使用properties文件，文件名为application.properties，可以通过如下命令创建configmap

```shell
kubectl create configmap card-config --from-file=application.properties
```

#### 编写Secret

主要保存原始card-bill服务application.properties文件中的密钥，因为secret对象无法以yaml活properties文件的形式挂载到POD中，所以决定用环境变量的形式进行传递。但原始card-bill服务的配置项是类似`card.bill.bond.privatekey`的形式，命名不符合shell环境变量的要求，还好spring支持灵活的解析，故将其名字改为`cardBillBondPrivatekey`的形式。

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: card-secret
type: Opaque
data:
  cardBillBondPrivatekey=MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAJIcWzGOK3Pn2JeCT6iLZNg2LJXdZR43CSZBRQsyy+zuBV3AizNPK8y+ONFdjP8VwuHkeZqrae76z7pH/m/B+g+PlQJ/tI3Qv77S+pr9yq/FvHNXPrK6J60SYsQQiUDrEY25A3R1JVXytjAaEwcTW/nWuEKnY6xHsMuk2KtrFCbNAgMBAAECgYBB+4RDUMzWvvDVGwgWOT0FVxGzbBPqHTiIihlAAWSOTr8lo3o5ZZuGDrFh+zldSNqFYMR50Mc6IRIGMdT5a0Qda9O28ah1XND7bt0RwytFYrFwRlILgo5kDEAsGk2ZVwCZFBxDdTN3OjX1ic7bUb2Ea3unR7C8e2IuTt22B622kQJBAM44cqPDoOz259WKoo+9O5a0wLq0XFHr6JGoelFyTZxVAjFD2920vZhfsYucfheRdULG8qjcGxIh3dR+otmPtOsCQQC1YWHC08RCW9C6llXqQUdcVKfItB4b5BroslPCQhBvWMtt0mv6/cGmYHYMDhH098FKfNyuOXmlZQyZIY9JNQUnAkBifhla2AOTSfW+SuGLb2D3gMsQITZ6tga1Eteg8Mvan8tVRkjLohhvnzzIJm0eyo1L4INjXQTc6yns5LLY4EcTAkAtapbqC9CGtSrMrbwRjgrqSaBBlyg636EFRzHF4HjxCJDXjOrQzB1jJaApYJSKfEb/+cfgMDAPg//lkAuqzwXdAkBfLnQemLv7QaLsDproHUxaRxvEbj9ci7Qsry29rpLQYFtvoWacXiHTjff2dLXGVTCsu0flxsCqoaWplTXOUQCc
  cardBillBondPublickey=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCSHFsxjitz59iXgk+oi2TYNiyV3WUeNwkmQUULMsvs7gVdwIszTyvMvjjRXYz/FcLh5Hmaq2nu+s+6R/5vwfoPj5UCf7SN0L++0vqa/cqvxbxzVz6yuietEmLEEIlA6xGNuQN0dSVV8rYwGhMHE1v51rhCp2OsR7DLpNiraxQmzQIDAQAB
  cardBillBondAesSaltKey=JXO8tTU7Ig
  cardBillBondAeskey=YtRNu0eD1dLQr/u/pb6AMw==
  cardBillBondVectorKey=Szn21EI2KlJZv9WZ

```



#### 编写Deployment

##### 配置和代码相分离

springboot本身就支持配置和代码分离，虽然jar包中本身就包含一个默认的application.properties文件，但只要在jar包所在目录的config目录下也有一个application.properties文件，就会覆盖jar包中原有的配置文件。所以考虑将application.properties做成一个configmap挂载到${HOME}/config目录下。

> ${HOME}是card-bill服务的运行目录，在Dockerfile中被定义为POD中的`/app`目录。

configmap的详情参见“编写configmap”小节。

```yaml
          volumeMounts:
          - mountPath: /app/config   # spring boot应用优先读取jar包所在目录的config子目录下的配置
            name: config-volume
            readOnly: true
...
      volumes:
      - name: config-volume
        configMap:
          name: card-config
      - name: log-volume
        emptyDir: {}                 # 使用emptyDir作为日志目录
```



##### 独立保存密钥

存放到secret中，以环境变量的形式传递给新的card-bill服务，参见“编写Secret”小节。

```yaml
          env:
            - name: cardBillBondPrivatekey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondPrivatekey
            - name: cardBillBondPublickey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondPublickey
            - name: cardBillBondAesSaltKey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondAesSaltKey
            - name: cardBillBondAeskey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondAeskey
            - name: cardBillBondVectorKey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondVectorKey
```



##### 日志

使用emptyDir卷config-volume保存日志。

```yaml
          volumeMounts:
          - mountPath: /app/config   # spring boot应用优先读取jar包所在目录的config子目录下的配置
            name: config-volume
            readOnly: true
          - mountPath: /app/logs     # 日志目录
            name: log-volume
...
      volumes:
      - name: config-volume
        configMap:
          name: card-config
      - name: log-volume
        emptyDir: {}                 # 使用emptyDir作为日志目录
```



##### 资源需求和 QoS 保证

设置为garunteed级别。

###### CPU

按需设定，这里设定为4个CPU

###### 内存

根据制作Dockerfile时启动JAVA进程的堆内存相应设置，设置为堆内存大小（1G）的1.5倍。

```yaml
          resources:
            limits:
              memory: 1.5Gi
              cpu: 4
            requests:
              memory: 1.5Gi
              cpu: 4
```



##### 亲和性设置

设置成副本之间不可以位于统一个节点上。

```yaml
    spec:
      affinity:
        podAntiAffinity:  # 指定是nodeAntiAffinity
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                    - cardbill
            topologyKey: kubernetes.io/hostname  # 在节点上寻找特定label的pod
```



##### 探活与优雅启动

我的理解，探活就是优雅启动。

> 没有时间找如何使用tini的方式了。

SpringBoot 判断是否是 kubernetes 环境的逻辑很简单，检查是否有 `*_SERVICE_HOST` 和`*_SERVICE_PORT` 这两个环境变量（需要spring boot 2.3 支持）。

在 spring boot 2.3 中引入了容器探针，也就是增加了 `/actuator/health/liveness` 和 `/actuator/health/readiness` 这两个健康检查路径，对于部署在 k8s 中的应用，spring-boot-actuator 将通过这两个路径自动进行健康检查。如果应用运行在 k8s 环境，这些健康检查自动启动，可以配置`management.endpoint.health.probes.enabled=true` 在任何环境中启用他们。所以需要在application.properties中添加如下配置：

```properties
management.endpoint.health.probes.enabled=true
```

- Spring Boot 启动过程中的K8S探针如下

  ![Spring Boot 启动过程中的K8S探针](https://github.com/XiaokaiDong/geektime_cloud_native/blob/main/eight/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84K8S%E6%8E%A2%E9%92%88.png)

- Spring Boot 关闭过程中的K8S探针如下：

  ![Spring Boot 关闭过程中的K8S探针](https://github.com/XiaokaiDong/geektime_cloud_native/blob/main/eight/Spring%20Boot%20%E5%85%B3%E9%97%AD%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84K8S%E6%8E%A2%E9%92%88.png)
  
  ```yaml
            livenessProbe:
              httpGet:
                path: /actuator/health/liveness
                port: 9090
              initialDelaySeconds: 10
              failureThreshold: 10
              timeoutSeconds: 10
              periodSeconds: 5
            readinessProbe:
              httpGet:
                path: /actuator/health/readiness
                port: 9090
              initialDelaySeconds: 10
              timeoutSeconds: 10
              periodSeconds: 5
  ```
  
  

##### 优雅终止

> 来源于“[SpringBoot 2.3 新特性之优雅停机，这波操作太秀了！](https://javazhiyin.blog.csdn.net/article/details/106270860?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link)”；

在最新的 spring boot 2.3 版本，内置此功能，不需要再自行扩展容器线程池来处理，目前 spring boot 嵌入式支持的 web 服务器（Jetty、Reactor Netty、Tomcat 和 Undertow）以及反应式和基于 Servlet 的 web 应用程序都支持优雅停机功能。

当使用server.shutdown=graceful启用时，在 web 容器关闭时，web 服务器将不再接收新请求，并将等待活动请求完成的缓冲期。设置如下：

```properties
#优雅关机
server.shutdown=graceful
#缓冲器最大等待时间
spring.lifecycle=timeout-per-shutdown-phase: 30s
```

优雅终止涉及到两个类：

- org.srpingframework.boot.web.server.Shutdown;
- org.srpingframework.boot.web.server.WebServer;

**但这个方案最大的问题是它支持的是SIGINT而不是SIGTERM信号！看来还需要转化一下信号！还需要进一步研究**。

##### 最终的Deployment文件

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cardbill-deployment
spec:
  replicas: 4
  selector:
    matchLabels:
      app: cardbill
  strategy:
    rollingUpdate:
      maxSurge: 25%  # 发布新版本的时候，先用新版本启动maxSurge比例的POD	
      maxUnavailable: 25%  # 如果不Ready的POD达到了maxUnavailable，发布升级就停止直到有人介入
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: cardbill
    spec:
      affinity:
        podAntiAffinity:  # 指定是nodeAntiAffinity
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                    - cardbill
            topologyKey: kubernetes.io/hostname  # 在节点上寻找特定label的pod
      containers:
        - name: cardbill
          image: cardbill
          volumeMounts:
          - mountPath: /app/config   # spring boot应用优先读取jar包所在目录的config子目录下的配置
            name: config-volume
            readOnly: true
          - mountPath: /app/logs     # 日志目录
            name: log-volume
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 9090
            initialDelaySeconds: 10
            failureThreshold: 10
            timeoutSeconds: 10
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 9090
            initialDelaySeconds: 10
            timeoutSeconds: 10
            periodSeconds: 5
          env:
            - name: cardBillBondPrivatekey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondPrivatekey
            - name: cardBillBondPublickey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondPublickey
            - name: cardBillBondAesSaltKey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondAesSaltKey
            - name: cardBillBondAeskey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondAeskey
            - name: cardBillBondVectorKey
              valueFrom:
                secretKeyRef:
                  name: card-secret
                  key: cardBillBondVectorKey
          resources:
            limits:
              memory: 1.5Gi
              cpu: 4
            requests:
              memory: 1.5Gi
              cpu: 4
      volumes:
      - name: config-volume
        configMap:
          name: card-config
      - name: log-volume
        emptyDir: {}                 # 使用emptyDir作为日志目录
      restartPolicy: Always
```

### 作业二

> 除了将 httpServer 应用优雅的运行在 Kubernetes 之上，我们还应该考虑如何将服务发布给对内和对外的调用方。
> 来尝试用 Service, Ingress 将你的服务发布给集群外部的调用方吧
> 在第一部分的基础上提供更加完备的部署 spec，包括（不限于）
>
> - Service
> - Ingress
>
> 可以考虑的细节
>
> - 如何确保整个应用的高可用
> - 如何通过证书保证 httpServer 的通讯安全

#### Service

创建clusterIP类型的service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: card-bill
spec:
  type: ClusterIP
  ports:
    - port: 80
      protocol: TCP
      targetPort: 9090
  selector:
    app: cardbill

```

#### Ingress

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: gateway
  annotations:
    kubernetes.io/ingress.class: "nginx"  #当有多个ingress Controller时指定交给NGINX的ingress Controller处理
spec:
  tls:
    - hosts:
        - example.com
      secretName: example-tls  #配置TLS服务是，KEY和CERT去这个secret对象里寻找
  rules:   # 规则
    - host: example.com  #规则生效的域名
      http:
        paths:
          - path: "/cardBill"
            pathType: Prefix   # 最终的规则为访问“example.com/cardBill/**”时转发到名为nginx的服务
            backend:
              service:
                name: card-bill
                port:
                  number: 80
```

secret example-tls如下：

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: example-tls
data:
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURMVENDQWhXZ0F3SUJBZ0lVVnVFWW11VHdxYXVFQjlxaGNSQUNRZDEyS0Frd0RRWUpLb1pJaHZjTkFRRUwKQlFBd0pqRVRNQkVHQTFVRUF3d0tZMjVqWVcxd0xtTnZiVEVQTUEwR0ExVUVDZ3dHWTI1allXMXdNQjRYRFRJeApNVEV3TWpFeE1URXdNVm9YRFRJeU1URXdNakV4TVRFd01Wb3dKakVUTUJFR0ExVUVBd3dLWTI1allXMXdMbU52CmJURVBNQTBHQTFVRUNnd0dZMjVqWVcxd01JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0MKQVFFQTVJUlY1TGJIT0tEVjE1NEZBUk55cE1IUzhKaUIrSXdBT3ZNQzR0R0xKdUg4SndsV3JnaVR4dW9JQjJDegpwVUp2RjZZck9PVGlsYTdkc1NMNTVLMWZuY0wxZlR6VVIrSk9ydkVPbndORjJRSEZKSU1vMzBqNmZsNmVWSFdqClhkM2tNMDc0ZnNKYkc0ZVBCR2YzYmNVamNoWjlPZ09JQXpCdXpSbDhzSlRSZnJuRkl0eUxhUjZZOUtRRGNYdzAKSWU1VkIyM2Q2ZGRJcDJvMzhtS2FQR1RQU0hhZDVUSWMvaXdscmlzaGxNZ2VBcEZLN0YyL0ZURDlNcytzWE94Mwp6Z2FSN2tUR0xvQzc3N1pQNTkvMVplUmxWSEora1djY2dESHpsQXVTZy9JemQ5NTZJUFhZTTNkTWZ2alNpZXZnCmJsQkJmNnkvcFdiVi9TVFdsdE4wSk9iMFZRSURBUUFCbzFNd1VUQWRCZ05WSFE0RUZnUVV2RStkaDlJUXVZVWIKdkxYbXlpMTQwUGZtcC9zd0h3WURWUjBqQkJnd0ZvQVV2RStkaDlJUXVZVWJ2TFhteWkxNDBQZm1wL3N3RHdZRApWUjBUQVFIL0JBVXdBd0VCL3pBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVFFQWNvYzVVaHRlNVNkWWtXaXArbnAwCnp2RnQ2YytENUN4U3Q5aXNYT3QrY3MxQkw5elRKRkNWdFl2TlIrUXhLWTdnaEh0NkphUjByRFpPa3VCY1pXbkwKTjVqOVRWWng4OG1YbEJMMlFZT21MWjNUcUlVTnlJMjAxUGxIZmZMb1BxaHZTeGZ4bGg4VnA4NFNaV1lucU5KMQo0cHF4WDFiYk8vZnM3QVNEaVRpZEowMFM4UjJsZTc0SEU5L0dBbnpuMTEvWTE0L3J1NjRuR2QxdVJQb2JTQUlICmI1UTRjYUtOWXBmMFhMMXVuZmZsZmFQb292eFN1ZHI1dEYzeUdrTERSaUNNdURidjNsNXBkbmdpWHdBOGZmblgKTVB1aFB0UEtXLzdtQzZFUUF4Y1BWa2R6UjRKbDQzM2lYNnJ0bXRONW5tRXJ3NEF6dUY4ZGcxWUN4ZU04MzltcQpmUT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRRGtoRlhrdHNjNG9OWFgKbmdVQkUzS2t3ZEx3bUlINGpBQTY4d0xpMFlzbTRmd25DVmF1Q0pQRzZnZ0hZTE9sUW04WHBpczQ1T0tWcnQyeApJdm5rclYrZHd2VjlQTlJINGs2dThRNmZBMFhaQWNVa2d5amZTUHArWHA1VWRhTmQzZVF6VHZoK3dsc2JoNDhFClovZHR4U055Rm4wNkE0Z0RNRzdOR1h5d2xORit1Y1VpM0l0cEhwajBwQU54ZkRRaDdsVUhiZDNwMTBpbmFqZnkKWXBvOFpNOUlkcDNsTWh6K0xDV3VLeUdVeUI0Q2tVcnNYYjhWTVAweXo2eGM3SGZPQnBIdVJNWXVnTHZ2dGsvbgozL1ZsNUdWVWNuNlJaeHlBTWZPVUM1S0Q4ak4zM25vZzlkZ3pkMHgrK05LSjYrQnVVRUYvckwrbFp0WDlKTmFXCjAzUWs1dlJWQWdNQkFBRUNnZ0VBVUd5R3NrVGxubmQwYXpzdzlhejdoeUt6ODNzcEd1bGkxMXhaWXF4dXRkT0kKNDlBMGtuRndXT3hhd1FYMms2M3EzVDdkTFZ2WXB1ZHhISHQ3eVZCL08wMjNDa21UU0cxTVZlTit5dFhqQ2puRwpRVkJyM1JHWkgwcDduS3YrUC9YczcyWFdyUDRJQkl0VCtUQUI4NzhTOTM4VXVZc3Vuamk0ZGpTSEhycHhkSkNRCm1JcG9GNWpCUzg4WjdpNWxQTHVXUTVYK2pmcGVqaU56dDlqcWJaL1BzRFcrZUNReUNkRlVBRFpwNGZrZTdWS1oKc2I0U3JlUlA4bmh5ejZxT29BcVkvOHVDenpUSlpOQjRObVVEWldyUzRMLzZlbFFGa2cyK1lhekhsV0xuTW5mbQpSaENlU3EyOGdkUlR2eHpCUS9Ta0ZBcFZVd0lzdmpGcFFXWTZzRnRMUVFLQmdRRDNFSHhvK2NYQjAwV1gzTW1ZClRQWUNEeEMxNlhTemlqbkdXTUZmdURnN3BkejJ0c1h1MEJDRlFLN1AwV0cxY1lJMTJDbXM3V0lIZi9tRWJORDgKK3Y4czllZkhFamZGNklHREFUMGxEMlhGS1lpZC9MRDdFQmFKejBRcnhvaVBTS0ZqMlBOeHVLRkhCM3hmQkZ1cQpKV2pSUHRxaDEwOVF3Qzl0bGRMNXFlTk1VUUtCZ1FEc3lCOXJnQVQveW9PalovRlFWYXBvbjE1aS9reWZZdGpPCm5qcVhxaStQRXIyS05zdUU5cXpUb2YyZldrSXVwWk5DemFOYlNhTjBCUHpKNnB2MW1IZTlIVmIyaUxkZUw2eksKeUZKcUhGVkVhcGNzOHo5dFhhVldJVGlrYW1MZ0l6ZWVPUnJDUVRXWDVzenZjQjFHNmhYMFRXY00vMHl5NkIyYgpJL2c3R1MwYXhRS0JnQnU3SWZ1MmJWZ0FHc09jNkpQTHI2RXpoN0NqYjVIblpleTVjWnNJMW1iN2l2MjJMaWxMCitVNjduK043b1BmNHNhRFJqbnYyZVJaV2F1OU9OM2J0eFU2S20yVmd5aG5RcXhqRlB0TzJFcm82bXpjQWNlejgKTlV0cWxFQkZuSFpZdEtTOGFUYk9mbXUyajJNcTNnOE8rK0RncVRHWk5USGZJSE93YVduVWc4ckJBb0dBVU9FaQo2bU4yVWJGcE9iM2RqZVZWS2h1VjhCYVJNYmhmK21QTis5UmtIbWoyV1duU0p2N2psZjYxVldOTlRBVyt3WWpnCmplUWZjeGZwQ1VlY01rMzhTSnJuQTVzN2wyNk5oVTdiNStiNXNUNy9tSmtXUjFNL2tLWVVaUVQ1OVRuU1c3ZUIKem16YjA2RkF5MkR1ZnpTaWZ5cVpVclU2QzdxQnNtYWMrZ0xsaDBrQ2dZRUFpdTYwR1d5Mnl4Tm45aXNjalZYbwpDUFNSbmtFM3MzM05YcnJwLzArbVZMdVVrUnRFcjBqWi9CTFl2NlRDMVhuaGdXMlZqdXZkWU9NMVV0WEM0M2JOCllXYXArUWMyYmZrRTJsWjZhdllNYXpEQ014Tzh5a3ZybWgwTWhHbDRkeXQvMWdCZnR1REphRVErQU5HaFEwRGMKbzFlWGlJTkh2aGdhTTN4YkdLREdMWFk9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K
type: kubernetes.io/tls
```

